import groovy.json.JsonSlurper

/**
 * 在 config.json 中 根据 appConfig 和 pkgConfig 来 include 本地模块
 */
def config = new JsonSlurper().parse(file("./config.json"))
// 第一次遍历 config.proConfig，决定是否 include
for (def pro in config.proConfig) {
    // 本地路径
    String localPath = pro.localPath
    // 把 mock 的 isApply 都置为 false 了
    if (localPath == ":feature:mock") {
        if (config.pkgConfig.isEmpty()) {
            pro.isApply = false
        }
    } else if (localPath.endsWith(":app")) {
        // 获取 feature 和 app 中间的名字，比如：launcher
        def appName = localPath.substring(":feature:".length(), localPath.length() - 4)
        // 通过比对 appConfig 中的数组来确定是否启用这个 app
        if (!config.appConfig.contains(appName)) {
            pro.isApply = false
        }
    } else if (localPath.endsWith(":pkg")) {
        if (!config.pkgConfig.isEmpty()) {
            // pkgConfig 如果不为空，就根据配置来启用
            def pkgName = localPath.substring(":feature:".length(), localPath.length() - 4)
            if (!config.pkgConfig.contains(pkgName)) {
                pro.isApply = false
            }
        }
    }
    // 使用本地 & 启用
    if (pro.useLocal && pro.isApply) {
        include pro.localPath
        project(pro.localPath).name = pro.localPath.substring(1).replace(":", "_")
    }
}
// 根据操作系统获取分割线（Windows 和 Mac 不同）
def ls = System.getProperty("line.separator")

List<String> proDeps = []
// 第一次遍历 config.proConfig，决定是否
for (def pro in config.proConfig) {
    boolean useLocal = pro.useLocal
    String localPath = pro.localPath
    String remotePath = pro.remotePath
    String name = localPath.replace(":", "_").replace("-", "_").substring(1)
    if (localPath != null) localPath = "\"$localPath\""
    if (remotePath != null) remotePath = "\"$remotePath\""
    boolean isApply = pro.isApply
    // 做一个拼接，拼接出一个格式如：
    // feature_mock : new DepConfig(false, true , ":feature:mock")
    // 的字符串
    proDeps.add(String.format("%-12s%-27s: new DepConfig(%-5s, %-5s, $localPath%s),",
            "", name, isApply, useLocal, remotePath == null ? "" : ", $remotePath"))
}
// 读取 Config.groovy 文件
def configFile = file('./buildSrc/src/main/groovy/Config.groovy')
def lines = configFile.readLines("utf8")
def configContent = new StringBuilder()
// 标记是否进入了 Never 标签，参看 Config.groovy /*Never delete this line*/
boolean enterNeverFlag = false
for (def line : lines) {
    if (enterNeverFlag) {
        if (line.contains("/*Never")) {
            configContent.append(ls).append(line)
            enterNeverFlag = false
        }
        continue
    }
    // 加换行 + 加每一行内容
    configContent.append(ls).append(line)
    // /*Never 如果包含了这个标记
    if (line.contains("/*Never")) {
        // 添加一行 /*Generated by "config.json"*/
        configContent.append(ls).append(String.format("%-12s/*Generated by \"config.json\"*/", ""))
        enterNeverFlag = true
        // 遍历上面设置好的配置，并添加到字符中
        for (String dep : proDeps) {
            configContent.append(ls).append(dep)
        }
    }
}
// 将重新组织的字符创重新写入文件
configFile.write(configContent.substring(ls.length()).toString())